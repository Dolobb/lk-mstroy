# Backend Blueprint — Аналитика выработки самосвалов

> Модуль аналитики самосвалов. Часть монорепо проекта КИП техники.
> Формат: псевдокод + пояснения на русском. Документ пишется итерационно.

---

## 0. Место в монорепо

```
repo/
├── server/          # существующий бэкенд КИП техники (не трогаем)
├── client/          # существующий фронтенд КИП техники (не трогаем)
├── dump-trucks/
│   ├── server/      # бэкенд самосвалов (этот документ)
│   └── client/      # фронтенд самосвалов (отдельное ТЗ)
└── config/          # общие конфиги (geozones.geojson и др.)
```

Модуль изолирован: своя БД (отдельная PostgreSQL-схема `dump_trucks`),
свой Express-сервер на отдельном порту, свой pipeline.
Общее с КИП: тот же TIS API, те же токены, тот же geozones.geojson (расширенный).

---

## 1. Конфиг-файлы

### 1.1. `config/dump-trucks-config.json` — главный конфиг объектов

Иерархия: Объект → Зоны (граница, погрузка, выгрузка, по месту).
Одна зона может одновременно быть в нескольких категориях (например, зона погрузки = зона "по месту").

```json
{
  "objects": [
    {
      "name": "Сингапай",
      "uid": "singapay",
      "smu": "СМУ г. Тюмень",
      "region": "Тюменская область",
      "zones": {
        "boundary": ["MOST_UID_BOUNDARY_1"],
        "loading":   ["MOST_UID_LOADING_1"],
        "unloading": ["MOST_UID_UNLOADING_1", "MOST_UID_UNLOADING_2"],
        "onsite":    ["MOST_UID_LOADING_1", "MOST_UID_ONSITE_1"]
      }
    },
    {
      "name": "Тобольск — мост",
      "uid": "tobolsk_bridge",
      "smu": "СМУ г. Тобольск",
      "region": "Тюменская область",
      "zones": {
        "boundary":  ["MOST_UID_BOUNDARY_2"],
        "loading":   ["MOST_UID_LOADING_2"],
        "unloading": ["MOST_UID_UNLOADING_3"],
        "onsite":    ["MOST_UID_ONSITE_2"]
      }
    }
  ]
}
```

**Поля объекта:**
- `name` — отображаемое название (идёт в фильтр СМУ/объект на UI)
- `uid` — внутренний ключ (используется как partition-ключ в БД)
- `smu` — название СМУ (для фильтра в шапке)
- `region` — регион (для фильтра в шапке)
- `zones.boundary` — uid полигона общей границы объекта (для определения "машина на объекте")
- `zones.loading` — uid зон погрузки
- `zones.unloading` — uid зон выгрузки
- `zones.onsite` — uid зон "работа по месту"

**Важно:** uid зон берётся из поля `uid` в `geozones.geojson` (поле `properties.uid`).

---

### 1.2. `config/dump-trucks-registry.json` — справочник самосвалов

```json
{
  "vehicles": [
    { "regNumber": "А446АТ172", "model": "КАМАЗ-6520",  "capacity": 20 },
    { "regNumber": "А525АТ172", "model": "КАМАЗ-65201", "capacity": 20 },
    { "regNumber": "Р028МС72",  "model": "Volvo FMX",   "capacity": 25 },
    { "regNumber": "Р424МС186", "model": "Shacman X3000","capacity": 25 }
  ]
}
```

**Поля:**
- `regNumber` — госномер (ключ сопоставления с данными TIS)
- `model` — марка/модель (отображается в таблице, колонка "Марка")
- `capacity` — грузоподъёмность в тоннах (умножается на кол-во рейсов)

**Загрузка:** При старте сервера читается в память как singleton (аналогично `vehicleRegistry.ts` в КИП).
Идентификация самосвала в телеметрии TIS: поле `nameMO` должно содержать слово "самосвал" (регистронезависимо).

---

### 1.3. `config/shifts.json` — общий с КИП, не меняем

```json
{
  "shift1": { "start": "07:30", "end": "19:30", "label": "1 смена" },
  "shift2": { "start": "19:30", "end": "07:30", "label": "2 смена" }
}
```

---

### 1.4. `config/geozones.geojson` — расширяем существующий

Файл общий с КИП. Для самосвалов никаких изменений в структуру не вносим —
все привязки зон к объектам и их типы хранятся в `dump-trucks-config.json`.
Геозоны используются только для получения координат полигонов по uid.

---

## 2. Схема базы данных

Отдельная PostgreSQL-схема `dump_trucks`. Все таблицы с префиксом в рамках схемы.

### 2.1. `dump_trucks.shift_records` — сводные данные за смену по каждому ТС

Главная таблица. Одна строка = одна машина × одна смена × один объект.
Это то, что отображается в основной таблице UI.

```sql
CREATE TABLE dump_trucks.shift_records (
  id                    SERIAL PRIMARY KEY,

  -- Идентификация записи
  report_date           DATE NOT NULL,
  shift_type            VARCHAR(10) NOT NULL,     -- 'shift1' | 'shift2'
  vehicle_id            VARCHAR(20) NOT NULL,     -- госномер ТС
  object_uid            VARCHAR(50) NOT NULL,     -- uid из dump-trucks-config.json

  -- Тип работы (определяется алгоритмом)
  work_type             VARCHAR(20) NOT NULL,     -- 'delivery' | 'onsite' | 'unknown'

  -- Данные из справочника (денормализованы для скорости отчётов)
  vehicle_model         VARCHAR(200),             -- из dump-trucks-registry.json
  vehicle_capacity      NUMERIC(6,2),             -- грузоподъёмность, т

  -- Данные из ПЛ + Заявки (план)
  request_number        INTEGER,                  -- номер заявки из TIS
  applicant             VARCHAR(200),             -- заявитель
  cost_object           VARCHAR(200),             -- объект затрат
  plan_volume           NUMERIC(10,2),            -- плановый объём, т

  -- KPI из телеметрии (общие для обоих типов работы)
  engine_on_time_min    NUMERIC(8,2),             -- время работы ДВС, мин
  moving_time_min       NUMERIC(8,2),             -- время в движении (speed>0), мин
  kip_pct               NUMERIC(6,2),             -- КИП % = engine_on_time / 600 * 100, макс 100
  moving_pct            NUMERIC(6,2),             -- В движении % = moving_time / 600 * 100, макс 100

  -- Факт: доставка
  trips_count           INTEGER,                  -- кол-во валидных рейсов (пар погрузка→выгрузка)
  fact_volume           NUMERIC(10,2),            -- trips_count * vehicle_capacity, т
  volume_remainder      NUMERIC(10,2),            -- plan_volume - fact_volume, т
  avg_loading_stay_min  NUMERIC(8,2),             -- среднее время в зоне погрузки, мин
  avg_unloading_stay_min NUMERIC(8,2),            -- среднее время в зоне выгрузки, мин

  -- Факт: по месту
  onsite_stay_min       NUMERIC(8,2),             -- время стоянки (speed=0) на объекте, мин
  onsite_moving_min     NUMERIC(8,2),             -- время движения на объекте, мин
  fuel_consumed         NUMERIC(10,4),            -- расход топлива, л (из TIS engineIdlingTime + расчёт)

  -- Служебные
  created_at            TIMESTAMP DEFAULT NOW(),
  updated_at            TIMESTAMP DEFAULT NOW(),

  UNIQUE(report_date, shift_type, vehicle_id, object_uid)
);
```

---

### 2.2. `dump_trucks.trips` — детализация рейсов (таблица Сингапай-формата)

Одна строка = один рейс (одна пара погрузка/выгрузка) или аномалия.
Открывается как дополнительная вкладка в UI.

```sql
CREATE TABLE dump_trucks.trips (
  id                    SERIAL PRIMARY KEY,

  -- Привязка к сводной записи
  shift_record_id       INTEGER REFERENCES dump_trucks.shift_records(id) ON DELETE CASCADE,
  vehicle_id            VARCHAR(20) NOT NULL,
  report_date           DATE NOT NULL,
  shift_type            VARCHAR(10) NOT NULL,
  object_uid            VARCHAR(50) NOT NULL,

  -- Порядок рейса
  trip_number           INTEGER NOT NULL,         -- порядковый номер рейса в смене

  -- Зона погрузки
  loading_zone_uid      VARCHAR(50),              -- uid зоны погрузки
  loading_entry_time    TIMESTAMP,                -- въезд в зону погрузки
  loading_exit_time     TIMESTAMP,                -- выезд из зоны погрузки
  loading_stay_min      NUMERIC(8,2),             -- exit - entry, мин

  -- Зона выгрузки
  unloading_zone_uid    VARCHAR(50),              -- uid зоны выгрузки
  unloading_entry_time  TIMESTAMP,                -- въезд в зону выгрузки
  unloading_exit_time   TIMESTAMP,                -- выезд из зоны выгрузки
  unloading_stay_min    NUMERIC(8,2),             -- exit - entry, мин

  -- Путь (время в пути, а не расстояние — из трека)
  travel_to_unload_min  NUMERIC(8,2),             -- от выезда погрузки до въезда выгрузки
  travel_to_load_min    NUMERIC(8,2),             -- от выезда выгрузки до следующего въезда погрузки

  -- Статус рейса
  is_valid              BOOLEAN NOT NULL DEFAULT TRUE,
  anomaly_type          VARCHAR(30),              -- NULL | 'no_unloading' | 'no_loading'
  comment               TEXT,                     -- текстовый комментарий для UI

  created_at            TIMESTAMP DEFAULT NOW()
);
```

---

### 2.3. `dump_trucks.zone_events` — сырые события пересечений геозон

Промежуточная таблица. Хранит все входы/выходы из всех зон за смену.
Используется для построения trips и отладки.
Может быть опущена в первой версии если хранить только агрегаты.

```sql
CREATE TABLE dump_trucks.zone_events (
  id              SERIAL PRIMARY KEY,
  vehicle_id      VARCHAR(20) NOT NULL,
  report_date     DATE NOT NULL,
  shift_type      VARCHAR(10) NOT NULL,
  object_uid      VARCHAR(50) NOT NULL,
  zone_uid        VARCHAR(50) NOT NULL,
  zone_type       VARCHAR(20) NOT NULL,   -- 'boundary' | 'loading' | 'unloading' | 'onsite'
  event_type      VARCHAR(10) NOT NULL,   -- 'entry' | 'exit'
  event_time      TIMESTAMP NOT NULL,
  created_at      TIMESTAMP DEFAULT NOW()
);

CREATE INDEX ON dump_trucks.zone_events (vehicle_id, report_date, shift_type);
```

---

### 2.4. `dump_trucks.requests` — заявки из TIS (аналог таблицы requests в КИП)

```sql
CREATE TABLE dump_trucks.requests (
  id              SERIAL PRIMARY KEY,
  request_id      INTEGER UNIQUE,
  number          INTEGER,
  status          VARCHAR(30),
  date_create     TIMESTAMP,
  applicant       VARCHAR(200),
  cost_object     VARCHAR(200),
  plan_volume     NUMERIC(10,2),           -- плановый объём в тоннах (из заявки)
  raw_json        JSONB,
  created_at      TIMESTAMP DEFAULT NOW()
);
```

---

### 2.5. `dump_trucks._migrations` — журнал миграций

```sql
CREATE TABLE dump_trucks._migrations (
  name        VARCHAR(255) PRIMARY KEY,
  applied_at  TIMESTAMP DEFAULT NOW()
);
```

---

## 3. Структура файлов модуля

```
dump-trucks/server/src/
├── index.ts                      # Express-сервер, маршруты, запуск
├── migrate.ts                    # Скрипт миграций схемы dump_trucks
├── config/
│   ├── database.ts               # Пул соединений к схеме dump_trucks
│   └── env.ts                    # Переменные окружения (порт, токены и т.д.)
├── jobs/
│   ├── shiftFetchJob.ts          # Главный пайплайн: запуск после окончания смены
│   └── scheduler.ts              # Cron: запуск в 08:30 и 20:30 (через час после смены)
├── repositories/
│   ├── shiftRecordRepo.ts        # CRUD для shift_records
│   ├── tripRepo.ts               # CRUD для trips
│   ├── zoneEventRepo.ts          # CRUD для zone_events
│   ├── requestRepo.ts            # Upsert + запросы для requests
│   └── filterRepo.ts             # Фильтры для UI (объекты, регионы, СМУ)
├── services/
│   ├── tisClient.ts              # HTTP-клиент к TIS API (можно переиспользовать из КИП)
│   ├── tokenPool.ts              # Round-robin токены (переиспользовать из КИП)
│   ├── vehicleDetector.ts        # Определение самосвалов на объекте за смену
│   ├── workTypeClassifier.ts     # Классификация типа работы: delivery | onsite
│   ├── zoneAnalyzer.ts           # Анализ трека → события пересечений геозон (Turf.js)
│   ├── tripBuilder.ts            # Построение пар рейсов из событий зон
│   ├── kpiCalculator.ts          # Расчёт КИП, В движении из данных TIS
│   ├── requestParser.ts          # Парсинг заявок из TIS → plan_volume, applicant и т.д.
│   ├── dumpTruckRegistry.ts      # In-memory справочник самосвалов из JSON
│   └── objectConfigLoader.ts    # In-memory загрузка dump-trucks-config.json
├── types/
│   ├── domain.ts                 # Внутренние интерфейсы
│   └── tis-api.ts                # Типы ответов TIS (можно расшарить с КИП)
└── utils/
    ├── dateFormat.ts             # Работа с датами (переиспользовать из КИП)
    └── logger.ts                 # Логгер (переиспользовать из КИП)
```

---

## 4. Алгоритм определения самосвалов на объекте (Вариант А)

> Запускается в начале пайплайна для каждого объекта × смена.
> Вариант А: получаем трек всех самосвалов, проверяем кто был в boundary-зоне объекта.

```pseudocode
функция detectVehiclesOnObject(objectConfig, shiftWindow):
  // Шаг 1: получить список всех самосвалов из TIS
  allVehicles = getMonitoringStats(
    from: shiftWindow.start,
    to:   shiftWindow.end
  )
  // Фильтр: только те у кого nameMO содержит "самосвал" (регистронезависимо)
  dumpTrucks = allVehicles.filter(v → v.nameMO.toLowerCase().includes("самосвал"))

  // Шаг 2: загрузить полигон границы объекта
  boundaryPolygon = getPolygonByUid(objectConfig.zones.boundary[0])  // из geozones.geojson

  // Шаг 3: для каждого самосвала проверить был ли он внутри boundary
  result = []
  для каждого truck из dumpTrucks:
    trackPoints = truck.track  // массив {lon, lat, time, speed}
    wasOnObject = trackPoints.some(point →
      turf.booleanPointInPolygon([point.lon, point.lat], boundaryPolygon)
    )
    если wasOnObject:
      result.push(truck)

  вернуть result  // список ТС которые были на объекте в эту смену
```

---

## 5. Алгоритм классификации типа работы

> Запускается после определения списка машин на объекте.
> Приоритет: сначала проверяем "по месту", потом "доставка".

```pseudocode
функция classifyWorkType(truck, objectConfig, track):
  // Шаг 1: загрузить полигоны onsite-зон объекта
  onsitePolygons = objectConfig.zones.onsite.map(uid → getPolygonByUid(uid))
  boundaryPolygon = getPolygonByUid(objectConfig.zones.boundary[0])

  // Шаг 2: посчитать общее время на объекте (внутри boundary)
  timeOnObject = calcTimeInsidePolygon(track, boundaryPolygon)  // мин

  если timeOnObject == 0: вернуть 'unknown'

  // Шаг 3: посчитать время в onsite-зонах
  timeInOnsiteZones = 0
  для каждого polygon из onsitePolygons:
    timeInOnsiteZones += calcTimeInsidePolygon(track, polygon)

  // Шаг 4: проверить порог 60%
  onsiteRatio = timeInOnsiteZones / timeOnObject
  если onsiteRatio >= 0.60: вернуть 'onsite'

  // Шаг 5: проверить наличие хотя бы одной пары погрузка/выгрузка
  loadingPolygons   = objectConfig.zones.loading.map(uid → getPolygonByUid(uid))
  unloadingPolygons = objectConfig.zones.unloading.map(uid → getPolygonByUid(uid))

  wasInLoading   = track.some(p → любой loadingPolygon содержит точку p)
  wasInUnloading = track.some(p → любой unloadingPolygon содержит точку p)

  если wasInLoading && wasInUnloading: вернуть 'delivery'

  вернуть 'unknown'  // был на объекте, но не подошёл ни под один тип
```

---

## 6. Алгоритм анализа трека и построения рейсов

> Только для type = 'delivery'.
> Вход: полный трек точек за смену + конфиг зон объекта.
> Выход: массив событий zone_events + массив рейсов trips.

### 6.1. Построение событий пересечений (`zoneAnalyzer.ts`)

```pseudocode
функция buildZoneEvents(track, objectConfig):
  // Собрать все зоны (все типы, кроме boundary)
  zones = [
    ...objectConfig.zones.loading.map(uid   → { uid, type: 'loading',   polygon: getPolygon(uid) }),
    ...objectConfig.zones.unloading.map(uid → { uid, type: 'unloading', polygon: getPolygon(uid) }),
    ...objectConfig.zones.onsite.map(uid    → { uid, type: 'onsite',    polygon: getPolygon(uid) })
  ]

  events = []
  // Для каждой зоны отдельно отслеживаем статус нахождения
  zoneStatus = Map<zoneUid, { inside: boolean, entryTime: Timestamp }>

  для каждой точки point из track (хронологически):
    для каждой zone из zones:
      isInside = turf.booleanPointInPolygon([point.lon, point.lat], zone.polygon)
      prevStatus = zoneStatus.get(zone.uid) ?? { inside: false }

      если !prevStatus.inside && isInside:
        // Событие ВЪЕЗДА
        events.push({ zone.uid, zone.type, type: 'entry', time: point.time })
        zoneStatus.set(zone.uid, { inside: true, entryTime: point.time })

      если prevStatus.inside && !isInside:
        // Событие ВЫЕЗДА
        events.push({ zone.uid, zone.type, type: 'exit', time: point.time })
        zoneStatus.set(zone.uid, { inside: false })

  // Закрыть незакрытые зоны (машина осталась внутри в конце смены)
  для каждого [uid, status] из zoneStatus:
    если status.inside:
      events.push({ uid, type: 'exit', time: shiftWindow.end })

  вернуть events.sort(по времени)
```

### 6.2. Построение пар рейсов (`tripBuilder.ts`)

```pseudocode
функция buildTrips(zoneEvents):
  trips = []
  tripNumber = 1

  // Берём только события загрузки и выгрузки
  loadingEvents   = zoneEvents.filter(e → e.zoneType == 'loading')
  unloadingEvents = zoneEvents.filter(e → e.zoneType == 'unloading')

  // Строим пары: для каждого выезда из погрузки ищем следующий выезд из выгрузки
  // при условии что между ними не было ещё одного въезда в погрузку

  // Алгоритм работает с хронологическим списком всех событий погрузки и выгрузки:
  allEvents = [...loadingEvents, ...unloadingEvents].sort(по времени)

  currentLoading = null   // текущий открытый рейс (зафиксирован въезд в погрузку)
  loadingVisits = 0       // счётчик посещений погрузки без выгрузки

  для каждого event из allEvents:
    если event.zoneType == 'loading' && event.eventType == 'entry':
      если currentLoading != null:
        // Повторный въезд в погрузку без выгрузки — аномалия предыдущего рейса
        trips.push({
          tripNumber: tripNumber++,
          loading: currentLoading,
          unloading: null,
          isValid: false,
          anomalyType: 'no_unloading'
        })
      currentLoading = { entryTime: event.time, zoneUid: event.zoneUid }

    если event.zoneType == 'loading' && event.eventType == 'exit':
      если currentLoading != null:
        currentLoading.exitTime = event.time
        currentLoading.stayMin = diffMinutes(currentLoading.entryTime, event.time)

    если event.zoneType == 'unloading' && event.eventType == 'entry':
      если currentLoading == null:
        // Выгрузка без погрузки — аномалия
        trips.push({
          tripNumber: tripNumber++,
          loading: null,
          unloading: { entryTime: event.time, zoneUid: event.zoneUid },
          isValid: false,
          anomalyType: 'no_loading'
        })
      иначе:
        currentUnloading = { entryTime: event.time, zoneUid: event.zoneUid }

    если event.zoneType == 'unloading' && event.eventType == 'exit':
      если currentLoading != null && currentUnloading != null:
        currentUnloading.exitTime = event.time
        currentUnloading.stayMin = diffMinutes(currentUnloading.entryTime, event.time)

        // Валидный рейс — закрываем пару
        trips.push({
          tripNumber: tripNumber++,
          loading:   currentLoading,
          unloading: currentUnloading,
          travelToUnloadMin:  diffMinutes(currentLoading.exitTime, currentUnloading.entryTime),
          travelToLoadMin:    null,  // заполнится при следующем рейсе
          isValid: true,
          anomalyType: null
        })
        // Заполнить travelToLoad предыдущего рейса
        если trips.length >= 2:
          prevTrip = trips[trips.length - 2]
          если prevTrip.isValid:
            prevTrip.travelToLoadMin = diffMinutes(prevTrip.unloading.exitTime, currentLoading.entryTime)

        currentLoading = null
        currentUnloading = null

  // Незакрытый рейс в конце смены
  если currentLoading != null:
    trips.push({
      tripNumber: tripNumber++,
      loading: currentLoading,
      unloading: null,
      isValid: false,
      anomalyType: 'no_unloading'
    })

  вернуть trips
```

---

## 7. Расчёт KPI

```pseudocode
функция calculateKpi(monitoringData):
  SHIFT_NORM_MIN = 600  // эталонные 10 часов

  engineOnMin  = monitoringData.engineTime / 60   // TIS даёт в секундах
  movingMin    = monitoringData.movingTime  / 60

  kipPct     = min(engineOnMin / SHIFT_NORM_MIN * 100, 100)
  movingPct  = min(movingMin   / SHIFT_NORM_MIN * 100, 100)

  вернуть { engineOnMin, movingMin, kipPct, movingPct }


функция calculateDeliveryFact(trips, vehicleCapacity):
  validTrips  = trips.filter(t → t.isValid)
  tripsCount  = validTrips.length
  factVolume  = tripsCount * vehicleCapacity

  avgLoadingStay   = среднее(validTrips.map(t → t.loading.stayMin))
  avgUnloadingStay = среднее(validTrips.map(t → t.unloading.stayMin))

  вернуть { tripsCount, factVolume, avgLoadingStay, avgUnloadingStay }


функция calculateOnsiteFact(track, boundaryPolygon):
  onsiteStayMin   = 0
  onsiteMovingMin = 0

  для каждой пары соседних точек [p1, p2] из track:
    если обе точки внутри boundaryPolygon:
      segmentMin = diffMinutes(p1.time, p2.time)
      если p1.speed == 0:
        onsiteStayMin   += segmentMin
      иначе:
        onsiteMovingMin += segmentMin

  вернуть { onsiteStayMin, onsiteMovingMin }
```

---

## 8. Главный пайплайн (`shiftFetchJob.ts`)

```pseudocode
функция runShiftPipeline(date, shiftType):
  logger.info("Старт пайплайна", { date, shiftType })

  shiftWindow = getShiftWindow(date, shiftType)
  // Например: shiftType='shift2', date='2026-04-01'
  // → shiftWindow = { start: '2026-03-31 19:30', end: '2026-04-01 07:30' }

  // 1. Получить заявки из TIS (за 2 месяца, как в КИП)
  rawRequests = tisClient.getRequests(от: минус2месяца, до: date)
  requests = parseRequests(rawRequests)
  upsertRequests(requests)  // → dump_trucks.requests

  // 2. Получить ПЛ из TIS (для привязки ТС → заявка)
  rawRouteLists = tisClient.getRouteListsByDateOut(от: date-7дней, до: date)
  vehicleToRequestMap = buildVehicleRequestMap(rawRouteLists)
  // { 'А446АТ172': { requestNumber, applicant, costObject, planVolume } }

  // 3. Для каждого объекта из конфига
  для каждого objectConfig из dumpTrucksConfig.objects:
    logger.info("Обрабатываем объект", { object: objectConfig.name })

    // 4. Определить самосвалы на объекте
    vehiclesOnObject = detectVehiclesOnObject(objectConfig, shiftWindow)
    logger.info("Найдено ТС", { count: vehiclesOnObject.length })

    // 5. Для каждого самосвала на объекте
    для каждого truck из vehiclesOnObject:
      попытка:
        track = truck.track  // уже есть в данных мониторинга

        // 6. Классифицировать тип работы
        workType = classifyWorkType(truck, objectConfig, track)

        // 7. Посчитать KPI
        kpi = calculateKpi(truck)

        // 8. Данные из плана
        planData = vehicleToRequestMap.get(truck.moUid) ?? {}

        // 9. Данные из справочника
        registryInfo = dumpTruckRegistry.get(truck.moUid)
        // { model, capacity }

        // 10. Ветка расчётов по типу работы
        если workType == 'delivery':
          zoneEvents = buildZoneEvents(track, objectConfig)
          upsertZoneEvents(zoneEvents, { vehicleId, date, shiftType, objectUid })

          trips = buildTrips(zoneEvents)
          upsertTrips(trips, { vehicleId, date, shiftType, objectUid })

          deliveryFact = calculateDeliveryFact(trips, registryInfo.capacity)

          upsertShiftRecord({
            ...kpi, ...planData, ...deliveryFact,
            workType: 'delivery',
            vehicleId: truck.moUid,
            vehicleModel: registryInfo.model,
            vehicleCapacity: registryInfo.capacity,
            volumeRemainder: (planData.planVolume ?? 0) - deliveryFact.factVolume,
            reportDate: date,
            shiftType,
            objectUid: objectConfig.uid
          })

        если workType == 'onsite':
          boundaryPolygon = getPolygonByUid(objectConfig.zones.boundary[0])
          onsiteFact = calculateOnsiteFact(track, boundaryPolygon)

          upsertShiftRecord({
            ...kpi, ...planData, ...onsiteFact,
            workType: 'onsite',
            vehicleId: truck.moUid,
            vehicleModel: registryInfo.model,
            reportDate: date,
            shiftType,
            objectUid: objectConfig.uid
          })

        если workType == 'unknown':
          // Сохраняем запись с workType='unknown', факты пустые
          upsertShiftRecord({ ...kpi, workType: 'unknown', ... })

      ошибка (error):
        logger.error("Ошибка обработки ТС", { vehicleId: truck.moUid, error })
        // Продолжаем следующий ТС, не прерываем весь пайплайн

  logger.info("Пайплайн завершён", { date, shiftType })


// Cron-расписание (scheduler.ts)
// 08:30 — обработать смену 1 предыдущего дня
cron.schedule('30 8 * * *',  () → runShiftPipeline(вчера, 'shift1'))
// 20:30 — обработать смену 2 текущего дня (19:30-07:30 → завершилась в 07:30, +1 час = 08:30 следующего дня)
// Примечание: смена 2 заканчивается в 07:30. Значит её обрабатываем в 08:30 следующего дня.
// Итоговое расписание: оба запуска в 08:30, но для разных дат и смен:
// В 08:30 01.04 → обрабатываем shift1 за 01.04 (07:30-19:30 → ещё не завершилась!)
// Правильно: shift1 (07:30-19:30) завершается в 19:30 → запуск в 20:30 того же дня
//            shift2 (19:30-07:30) завершается в 07:30 → запуск в 08:30 следующего дня
cron.schedule('30 20 * * *', () → runShiftPipeline(сегодня,  'shift1'))
cron.schedule('30 8  * * *', () → runShiftPipeline(вчера,    'shift2'))
```

---

## 9. REST API эндпоинты

```pseudocode
GET /api/dt/health
  → { status: "ok", module: "dump-trucks" }


GET /api/dt/summary?date=YYYY-MM-DD&shift=shift1&objectUid=singapay
  // Сводные KPI для шапки UI: кол-во ТС, средние КИП и В движении по сменам
  records = getShiftRecords({ date, shift, objectUid })
  → {
      vehicleCount: records.length,
      shift1: { avgKip, avgMoving },
      shift2: { avgKip, avgMoving }
    }


GET /api/dt/records?from=YYYY-MM-DD&to=YYYY-MM-DD&shift=&objectUid=&smu=&region=
  // Основная таблица. Записи за период с фильтрами.
  // По умолчанию from=to=вчера.
  records = getShiftRecords({ from, to, shift, objectUid, smu, region })
  // Обогатить данными из справочника (model, capacity)
  → records[]


GET /api/dt/trips?date=YYYY-MM-DD&shift=shift1&vehicleId=А446АТ172&objectUid=singapay
  // Детализация рейсов для конкретного ТС — открывается отдельной вкладкой
  trips = getTrips({ date, shift, vehicleId, objectUid })
  → trips[]


GET /api/dt/filters
  // Каскадные фильтры для UI
  → {
      objects: [{ uid, name, smu, region }],   // из dump-trucks-config.json
      smuList: string[],
      regions: string[]
    }


GET /api/dt/geozones?objectUid=singapay
  // GeoJSON зон конкретного объекта для карты
  // Возвращает только зоны из конфига этого объекта (все типы)
  → GeoJSON FeatureCollection


POST /api/dt/admin/fetch?date=YYYY-MM-DD&shift=shift1
  // Ручной запуск пайплайна (для конкретной даты и смены)
  runShiftPipeline(date, shift).catch(логировать)
  → { status: "started", date, shift }


POST /api/dt/admin/fetch-current
  // Запуск для текущей смены (например, в 13:00 — за период 07:30-13:00)
  // Определяет текущую смену и запускает пайплайн с shiftWindow.end = now()
  currentShift = getCurrentShift(now())
  runShiftPipeline(сегодня, currentShift, { endOverride: now() }).catch(логировать)
  → { status: "started", shift: currentShift, periodEnd: now() }
```

---

## 10. Переменные окружения (`.env`)

```
# Общие с КИП (можно переиспользовать)
TIS_API_URL=
TIS_API_TOKENS=token1,token2

# БД для модуля самосвалов
DT_DB_HOST=localhost
DT_DB_PORT=5432
DT_DB_NAME=
DT_DB_USER=postgres
DT_DB_PASSWORD=
DT_DB_SCHEMA=dump_trucks

# Сервер
DT_SERVER_PORT=3002

# Rate limit (мс между запросами к TIS на одно ТС)
DT_RATE_LIMIT_MS=30000
```

---

## 11. Поток данных (итоговая схема)

```
TIS API (внешний)
  │
  ├─ getRequests (2 месяца)
  │     ↓ parseRequests → upsertRequests → [dump_trucks.requests]
  │
  ├─ getRouteListsByDateOut (7 дней)
  │     ↓ buildVehicleRequestMap → { госномер → заявка }
  │
  └─ getMonitoringStats (все самосвалы за смену)
        ↓
      detectVehiclesOnObject  → фильтр: кто был в boundary-зоне
        ↓
      classifyWorkType        → 'delivery' | 'onsite' | 'unknown'
        ↓
      ┌─────────────────────────────────────────────┐
      │ delivery                │ onsite             │
      │                         │                    │
      │ buildZoneEvents (Turf)  │ calculateOnsiteFact│
      │       ↓                 │       ↓            │
      │ buildTrips              │ (stayMin, movingMin│
      │       ↓                 │  fuelConsumed)     │
      │ calculateDeliveryFact   │                    │
      └─────────────────────────────────────────────┘
              ↓                         ↓
        calculateKpi (engineTime, movingTime → %)
              ↓
        upsertShiftRecord → [dump_trucks.shift_records]
        upsertTrips       → [dump_trucks.trips]
        upsertZoneEvents  → [dump_trucks.zone_events]

                    ═══════════════════════

REST API (Express :3002)
  │
  GET /api/dt/records        ← основная таблица UI
  GET /api/dt/trips          ← детализация рейсов (доп. вкладка)
  GET /api/dt/summary        ← KPI-карточки в шапке
  GET /api/dt/filters        ← фильтры (объекты, регионы, СМУ)
  GET /api/dt/geozones       ← полигоны для карты
  POST /api/dt/admin/fetch   ← ручной запуск за дату/смену
  POST /api/dt/admin/fetch-current ← запуск для текущей смены
```

---

*Документ актуален на 18.02.2026. Следующий раздел: детализация `requestParser.ts` и формат данных заявок TIS.*