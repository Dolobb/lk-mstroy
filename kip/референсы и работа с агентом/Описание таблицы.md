# Описание структуры таблицы «Расчёт загрузки ТС»

## Общие сведения

- **Источник данных**: API телематической информационной системы (ТИС). Формат API будет описан отдельно.
- **Объём**: ~350 строк/день, хранение без ротации (все данные сохраняются бессрочно).
- **Назначение**: расчёт выработки техники для отображения на интерактивной карте веб-интерфейса.
- **Обновление**: cron ежедневно в 07:30 (Екатеринбург, UTC+5), выгрузка за предыдущий день.

---

## Столбцы таблицы

### Блок 1 — Идентификация периода

| Название столбца | Техническое имя | Тип данных   | Описание |
|------------------|-----------------|--------------|----------|
| Дата             | report_date     | Date         | Дата проведения работ (ДД.ММ.ГГГГ) |
| Смена            | shift_type      | String/Enum  | Номер или наименование смены (например, «1 смена») |

### Блок 2 — Данные ТИС (сырые, приходят из API)

| Название столбца                          | Техническое имя     | Тип данных     | Описание |
|-------------------------------------------|----------------------|----------------|----------|
| Рег. №                                    | vehicle_id           | String         | Государственный регистрационный номер ТС |
| Марка                                     | vehicle_model        | String         | Модель техники (например, Автокран КС-45717-2Р) |
| Организация                               | company_name         | String         | Наименование филиала или дочернего общества |
| СМУ                                       | department_unit      | String         | Структурное подразделение (СМУ) или площадка базирования |
| Суммарное время пребывания на объекте      | total_stay_time      | Time/Interval  | Вычисляется через пересечение GPS-трека с GeoJSON-геозонами объектов. Время, пока ТС находилось внутри геозоны (ЧЧ:ММ:СС) |
| Время работы двигателя                    | engine_on_time       | Time/Interval  | `engineTime` из API getMonitoringStats (секунды → часы) |
| Время стоянки                             | idle_time            | Time/Interval  | Расчётное: `total_stay_time - engine_on_time` |
| Расход топлива по факту, л                | fuel_consumed_total  | Float          | Сумма `fuels[].rate` из API. Если несколько баков — суммируются |

### Блок 3 — Расчётные показатели

| Название столбца                          | Техническое имя   | Тип данных | Описание |
|-------------------------------------------|--------------------|------------|----------|
| Фактический расход, л/час                 | fuel_rate_fact     | Float      | Расчётное: `fuel_consumed_total / engine_on_time` |
| Время максимальной работы двигателя       | max_work_allowed   | Time       | Расчётное: `total_stay_time × (22/24)` — лимит полезной работы |
| Норма расхода, л/час                      | fuel_rate_norm     | Float      | Эталонный показатель расхода для данной модели техники. **Справочник** — хранится в конфигурационном файле, привязан к модели ТС |
| Расход при макс. работе двигателя         | fuel_max_calc      | Float      | Расчётное: `engine_on_time × fuel_rate_norm` — прогноз расхода за фактическое время работы |
| Факт / Норма (коэффициент)               | fuel_variance      | Float      | Расчётное: `fuel_rate_fact / fuel_rate_norm` — кратность отклонения от нормы. Если > 1 — перерасход |

### Блок 4 — KPI

| Название столбца              | Техническое имя      | Тип данных | Описание |
|-------------------------------|----------------------|------------|----------|
| Работа под нагрузкой, %       | load_efficiency_pct  | Percent    | **Главный KPI.** `min(engine_on_time / max_work_allowed, 1) × 100`. Cap на 100% |
| КИП, % Время работы ДВС      | utilization_ratio    | Percent    | `min(engine_on_time / total_stay_time, 1) × 100`. Cap на 100% |

> **Примечание**: столбцы «Работа на ХХ» и «Простой» являются комплементарными (= 1 - KPI) и **не реализуются**.

---

## Формулы расчёта (Logic Layer)

Все временные значения (ЧЧ:ММ:СС) предварительно переводятся в десятичные часы.
Пример: `01:30:00` = `1.5` часа.

| Показатель | Формула | Примечание |
|------------|---------|------------|
| Фактический расход, л/час | `V_rate = V_fact / T_engine` | Если `T_engine = 0`, результат = `0` |
| Макс. время работы в смену | `T_max = T_stay × (22/24)` | Технологический предел — 91.67% от времени на объекте |
| Расход при макс. работе | `V_max = T_engine × V_norm` | Фактическое время работы × паспортная норма |
| Факт / Норма | `K_fuel = V_rate / V_norm` | > 1 означает перерасход |
| Работа под нагрузкой, % | `L = min(T_engine / T_max, 1) × 100` | Принудительный cap на 100% |
| КИП, % | `KIP = min(T_engine / T_stay, 1) × 100` | Принудительный cap на 100% |

---

## Валидация данных

- `total_stay_time` не может превышать 24 часа.
- `engine_on_time ≤ total_stay_time` всегда.
- KPI-поля (`load_efficiency_pct`, `utilization_ratio`) ограничены диапазоном 0–100%.

---

## Цветовая индикация (UI Logic)

Применяется к столбцам **«Работа под нагрузкой»** и **«КИП»**:

| Диапазон     | Цвет                 | Значение |
|--------------|----------------------|----------|
| < 49%        | `#FF0000` (красный)  | Критически низкая эффективность |
| 49% – 60%    | `#0000FF` (синий)    | Требует внимания |
| > 61%        | `#008000` (зелёный)  | Целевой показатель (норма) |

---

## Справочник нормы расхода

Файл конфигурации (JSON) содержит соответствие `vehicle_model → fuel_rate_norm`.
Позволяет обновлять нормы без изменения кода.

---

## Маппинг полей: API getMonitoringStats → таблица

| Поле API               | Тип в API       | Поле таблицы         | Преобразование |
|-------------------------|-----------------|----------------------|----------------|
| `engineTime`            | int (секунды)   | `engine_on_time`     | `/ 3600` → часы |
| `fuels[].rate`          | float (литры)   | `fuel_consumed_total`| Сумма по всем бакам |
| `track[]` (GPS-точки)   | array           | `total_stay_time`    | Пересечение с GeoJSON-геозонами → время внутри зоны |
| `track[-1]` (последняя) | `{lat, lon}`    | `latitude/longitude` | Координаты маркера на карте |
| —                       | —               | `idle_time`          | `total_stay_time - engine_on_time` |

---

## Геозоны объектов

**Источник**: файлы GeoJSON с полигонами объектов (СМУ, площадки).

**Логика расчёта `total_stay_time`**:
1. Получаем массив `track[]` из getMonitoringStats (точки с координатами и временем)
2. Для каждой точки проверяем, попадает ли она в одну из GeoJSON-геозон (point-in-polygon)
3. Считаем суммарное время, пока ТС находилось внутри геозоны
4. Привязываем ТС к конкретному объекту (СМУ/department_unit) по геозоне, в которой оно провело больше всего времени

> Это отдельный этап реализации, требующий: загрузку GeoJSON-зон в систему, алгоритм point-in-polygon (Turf.js на сервере), обработку пограничных случаев (ТС перемещается между зонами).

---

## Смены

| Смена   | Время             | Ключ формата |
|---------|-------------------|--------------|
| Утро    | 07:30 → 19:30     | `DD.MM.YYYY_morning` |
| Вечер   | 19:30 → 07:30+1   | `DD.MM.YYYY_evening` |

- Границы смен хранятся в конфиге (по умолчанию 07:30/19:30)
- Период 00:00–07:30 относится к **вечерней смене предыдущего дня**
- Один путевой лист может покрывать несколько смен → для каждой смены отдельный запрос getMonitoringStats
- **Часовой пояс**: все времена в API — местное время. Часовой пояс определяется по первой точке GPS-трека из выгрузки мониторинга

---

## Связь сущностей (Заявки ↔ ПЛ ↔ ТС)

```
Заявка (getRequests)
  └─ number: 121061
        │
        │  regex из calcs[].orderDescr: "№121061/1 от ..."
        ▼
Путевой лист (getRouteListsByDateOut)
  └─ ts[]: [{idMO: 3241, regNumber: "С335РН72", nameMO: "..."}]
        │
        │  idMO → getMonitoringStats
        ▼
Мониторинг ТС → расчёт КИП/нагрузки → запись в БД
```

Прямой связи «заявка → ТС» в API нет. Путевой лист — единственное промежуточное звено.

### Схема таблиц PostgreSQL

```sql
requests        → хранит заявки (number, status, contactPerson, orders[])
route_lists     → путевые листы (ts_number, dateOut, status)
pl_calcs        → задания из ПЛ (route_list_id, extracted_request_number, objectExpend)
vehicles        → ТС из ПЛ (route_list_id, reg_number, id_mo, name_mo)
vehicle_records → расчётные данные КИП/нагрузки по сменам
```

JOIN: `requests.number = pl_calcs.extracted_request_number → route_lists → vehicles`

---

## Фильтрация ТС

- Список нужных ТС берётся из **справочника** (конфиг-файл), не из путевых листов
- Дополнительная фильтрация по подстроке в `nameMO` — конфигурируемые ключевые слова (например `["кран", "автокран"]`)
- Типы ТС для UI-фильтра хранятся в `config/vehicle-types.json`
